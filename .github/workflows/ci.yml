 # Symbols: ‚ùå ‚ö†Ô∏è ‚úÖ üö® üì∫ üìã ‚ÑπÔ∏è
name: CI ‚úÖ ‚ö†Ô∏è ‚ùå üö®

permissions:
  contents: read
  packages: write

on:
  workflow_dispatch: {}
  push:
    branches: [ main, master, staging ]
  pull_request:
    branches: [ main ]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: python

      - name: Autobuild
        uses: github/codeql-action/autobuild@v2

      - name: Run CodeQL analysis
        run: |
          echo "Skipping CodeQL analysis: not used in this repo right now"

  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install linters
        run: |
          python -m pip install --upgrade pip
          pip install flake8

      - name: Run flake8
        run: |
          flake8 hello_world || true

  build:
    needs: [security-scan, code-quality]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set image owner (lowercase)
        run: |
          OWNER=${{ github.repository_owner }}
          LOWER_OWNER=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')
          printf "IMAGE_OWNER=%s\n" "$LOWER_OWNER" >> $GITHUB_ENV

      - name: Debug image owner and tags
        run: |
          echo "IMAGE_OWNER=$IMAGE_OWNER"
          echo "TAG1=ghcr.io/$IMAGE_OWNER/fordigitaocean-hello:$GITHUB_SHA"
          echo "TAG2=ghcr.io/$IMAGE_OWNER/fordigitaocean-hello:latest"

      - name: Build and push Docker image to GHCR
        run: |
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --file hello_world/Dockerfile \
            --push \
            --tag ghcr.io/${IMAGE_OWNER}/fordigitaocean-hello:${GITHUB_SHA} \
            --tag ghcr.io/${IMAGE_OWNER}/fordigitaocean-hello:latest \
            hello_world
        env:
          DOCKER_BUILDKIT: 1

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f hello_world/requirements.txt ]; then pip install -r hello_world/requirements.txt; fi

      - name: Run hello script (background + smoke test)
        working-directory: hello_world
        run: |
          # start server in background, smoke-test it, then stop it so CI step doesn't hang
          python hello.py &
          SERVER_PID=$!
          # give server a moment to start
          sleep 2
          # try connecting a few times in case server needs more time
          curl --retry 5 --retry-delay 1 --fail http://127.0.0.1:8000/
          # cleanup background server (best-effort)
          kill $SERVER_PID || true

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Deploy to Droplet via SSH
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          port: 22
          script: |
            set -e
            # install docker if missing
            if ! command -v docker >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              curl -fsSL https://get.docker.com | sh
            fi

            # install compose plugin if missing
            if ! docker compose version >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get install -y docker-compose-plugin
            fi

            APP_DIR=/opt/ForDigitaOcean
            if [ -d "$APP_DIR" ]; then
              cd "$APP_DIR"
              git fetch --all
              git reset --hard origin/main
            else
              git clone https://github.com/Gubbya/ForDigitaOcean.git "$APP_DIR"
              cd "$APP_DIR"
            fi

            # login to GHCR if provided
            if [ -n "${GHCR_PAT}" ]; then
              echo "${GHCR_PAT}" | docker login ghcr.io -u Gubbya --password-stdin
            fi

            docker compose pull || true
            docker compose up -d --build

            # wait for the 'hello' service to become healthy (timeout configurable)
            SERVICE_NAME=hello
            TIMEOUT=60
            SLEEP=2
            RETRIES=$((TIMEOUT / SLEEP))
            CONTAINER_ID=$(docker compose ps -q "$SERVICE_NAME")
            if [ -n "$CONTAINER_ID" ]; then
              echo "Waiting up to ${TIMEOUT}s for $SERVICE_NAME to become healthy..."
              HEALTH=""
              for i in $(seq 1 $RETRIES); do
                HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-health{{end}}' "$CONTAINER_ID" 2>/dev/null || true)
                echo "Attempt $i/$RETRIES - health: ${HEALTH}"
                if [ "$HEALTH" = "healthy" ]; then
                  echo "$SERVICE_NAME is healthy"
                  break
                fi
                sleep $SLEEP
              done
              if [ "$HEALTH" != "healthy" ]; then
                echo "ERROR: $SERVICE_NAME failed to become healthy within ${TIMEOUT}s. Current health: ${HEALTH}"
                docker logs --tail 200 "$CONTAINER_ID" || true
                exit 1
              fi
            fi

            # If domain and email are provided, try to obtain TLS certs via certbot
            if [ -n "${DROPLET_DOMAIN}" ] && [ -n "${CERTBOT_EMAIL}" ]; then
              echo "DROPLET_DOMAIN and CERTBOT_EMAIL provided ‚Äî attempting certbot issuance if needed"
              mkdir -p ./nginx/certs ./nginx/www
              # if certs for domain not present, run certbot
              if [ ! -d "./nginx/certs/live/${DROPLET_DOMAIN}" ]; then
                echo "Requesting certificates for ${DROPLET_DOMAIN}"
                docker compose run --rm certbot certonly --webroot -w /var/www/certbot -d "${DROPLET_DOMAIN}" --email "${CERTBOT_EMAIL}" --agree-tos --non-interactive || true
                # render ssl.conf from template
                if [ -f ./nginx/ssl.conf.template ]; then
                  sed 's/{{DOMAIN}}/'"${DROPLET_DOMAIN}"'/g' ./nginx/ssl.conf.template > ./nginx/ssl.conf
                fi
                # reload nginx to pick up new certs and ssl.conf
                docker compose up -d --no-deps --build nginx || true
                # try an nginx config test and reload
                NGINX_CID=$(docker compose ps -q nginx)
                if [ -n "$NGINX_CID" ]; then
                  docker exec "$NGINX_CID" nginx -t || true
                  docker exec "$NGINX_CID" nginx -s reload || true
                fi
              else
                echo "Certificates already present for ${DROPLET_DOMAIN}, skipping issuance"
              fi
            else
              echo "DROPLET_DOMAIN or CERTBOT_EMAIL not set; skipping certbot issuance"
            fi
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          DROPLET_DOMAIN: ${{ secrets.DROPLET_DOMAIN }}
          CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging'
    steps:
      - name: Deploy to Staging Droplet via SSH
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          port: 22
          script: |
            set -e
            # install docker if missing
            if ! command -v docker >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              curl -fsSL https://get.docker.com | sh
            fi

            # install compose plugin if missing
            if ! docker compose version >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get install -y docker-compose-plugin
            fi

            APP_DIR=/opt/ForDigitaOcean
            if [ -d "$APP_DIR" ]; then
              cd "$APP_DIR"
              git fetch --all
              # checkout the staging branch if present
              git checkout -f staging || true
              git reset --hard origin/staging || true
            else
              git clone https://github.com/Gubbya/ForDigitaOcean.git "$APP_DIR"
              cd "$APP_DIR"
              git checkout -f staging || true
            fi

            # login to GHCR if provided
            if [ -n "${GHCR_PAT}" ]; then
              echo "${GHCR_PAT}" | docker login ghcr.io -u Gubbya --password-stdin
            fi

            docker compose pull || true
            docker compose up -d --build

            # wait for the 'hello' service to become healthy (timeout configurable)
            SERVICE_NAME=hello
            TIMEOUT=60
            SLEEP=2
            RETRIES=$((TIMEOUT / SLEEP))
            CONTAINER_ID=$(docker compose ps -q "$SERVICE_NAME")
            if [ -n "$CONTAINER_ID" ]; then
              echo "Waiting up to ${TIMEOUT}s for $SERVICE_NAME to become healthy..."
              HEALTH=""
              for i in $(seq 1 $RETRIES); do
                HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-health{{end}}' "$CONTAINER_ID" 2>/dev/null || true)
                echo "Attempt $i/$RETRIES - health: ${HEALTH}"
                if [ "$HEALTH" = "healthy" ]; then
                  echo "$SERVICE_NAME is healthy"
                  break
                fi
                sleep $SLEEP
              done
              if [ "$HEALTH" != "healthy" ]; then
                echo "ERROR: $SERVICE_NAME failed to become healthy within ${TIMEOUT}s. Current health: ${HEALTH}"
                docker logs --tail 200 "$CONTAINER_ID" || true
                exit 1
              fi
            fi

            # If domain and email are provided, try to obtain TLS certs via certbot
            if [ -n "${DROPLET_DOMAIN}" ] && [ -n "${CERTBOT_EMAIL}" ]; then
              echo "DROPLET_DOMAIN and CERTBOT_EMAIL provided ‚Äî attempting certbot issuance if needed"
              mkdir -p ./nginx/certs ./nginx/www
              if [ ! -d "./nginx/certs/live/${DROPLET_DOMAIN}" ]; then
                echo "Requesting certificates for ${DROPLET_DOMAIN}"
                docker compose run --rm certbot certonly --webroot -w /var/www/certbot -d "${DROPLET_DOMAIN}" --email "${CERTBOT_EMAIL}" --agree-tos --non-interactive || true
                if [ -f ./nginx/ssl.conf.template ]; then
                  sed 's/{{DOMAIN}}/'"${DROPLET_DOMAIN}"'/g' ./nginx/ssl.conf.template > ./nginx/ssl.conf
                fi
                docker compose up -d --no-deps --build nginx || true
                NGINX_CID=$(docker compose ps -q nginx)
                if [ -n "$NGINX_CID" ]; then
                  docker exec "$NGINX_CID" nginx -t || true
                  docker exec "$NGINX_CID" nginx -s reload || true
                fi
              else
                echo "Certificates already present for ${DROPLET_DOMAIN}, skipping issuance"
              fi
            else
              echo "DROPLET_DOMAIN or CERTBOT_EMAIL not set; skipping certbot issuance"
            fi
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          DROPLET_DOMAIN: ${{ secrets.DROPLET_DOMAIN }}
          CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}

  debug:
    runs-on: ubuntu-latest
    steps:
      - name: üìã Show last 50 lines of runner profile and shell rc
        run: |
          # show runner profile files if present (best-effort)
          if [ -f ~/.profile ]; then echo "=== ~/.profile (last 50 lines) ==="; tail -n 50 ~/.profile || true; fi
          if [ -f ~/.bashrc ]; then echo "=== ~/.bashrc (last 50 lines) ==="; tail -n 50 ~/.bashrc || true; fi

      - name: üì∫ Show recent GitHub Actions workflow runs (via API)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # the runner may not have the gh CLI installed; use the Actions API as a fallback
          echo "Listing recent workflow runs (raw JSON, truncated)"
          curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?per_page=5" | sed -n '1,200p' || true

      - name: ‚ÑπÔ∏è Show docker status locally
        run: |
          docker --version || true
          docker ps -a || true
